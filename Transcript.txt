This file should contain one of two things: Either a complete transcript
showing the prompts and responses for any LLM use that helped you to complete
this project, or else a statement saying that you did not use any LLM to help
you to complete this project.

User: Wwhat is the current error in my BST insert?

AI: Looking at your BST insert method, there's a logical error in the comparison condition. Currently you have:

if (root.getData().compareTo(e) >= 0)
    root.setLeft(insertHelp(root.getLeft(), e));
The issue is with the >= 0 condition. In a proper BST:

	•  Values less than the current node should go to the left
	•  Values greater than the current node should go to the right
	•  Equal values should typically go to the left (or right, but be consistent)

Your current logic puts values that are greater than or equal to the current node on the left, which is backwards.

Here's the corrected version:
private BinaryNode<T> insertHelp(BinaryNode<T> root, T e) {
    if (root == null)
        return new BinaryNode<T>(e);
    if (e.compareTo(root.getData()) <= 0)
        root.setLeft(insertHelp(root.getLeft(), e));
    else
        root.setRight(insertHelp(root.getRight(), e));
    return root;
}

The key changes:

	1. Compare e.compareTo(root.getData()) instead of root.getData().compareTo(e)
	2. Use <= 0 to put smaller/equal values on the left
	3. Put larger values on the right

This ensures your BST maintains the proper ordering property where left subtree contains smaller values and right subtree contains larger values.

return bTree.findNode(name); why is this returning an error?

The method findNode(City) in the type BSTree is not applicable for arguments String

The issue is a type mismatch. Your bTree is declared as BSTree<City>, so the findNode method expects a City object, but you're passing a String (the city name).

You need to create a temporary City object with the name you're searching for.
 Since the BST compares cities by name only (as defined in City.compareTo)
, the x and y values don't matter for the search:
public String info(String name) {
    City searchCity = new City(name, 0, 0);
    return bTree.findNode(searchCity);
}

The City.compareTo method only compares city names:
public int compareTo(City other) {
    return this.cityName.compareTo(other.cityName);
}
So creating a temporary City object with coordinates (0, 0) will work correctly for searching by name, 
since only the name field is used in the comparison.